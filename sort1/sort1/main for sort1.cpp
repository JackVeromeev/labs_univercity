#include<stdio.h>
#include<conio.h>
#include<locale.h>
#include<stdlib.h>
#include<Windows.h>
#include<math.h>

void bubble(int *m, int n);

void sort_all(int *m, int n);

void sort_all_by_zero(int *m, int n);


int main()
{
	setlocale(LC_ALL, "RUSSIAN");
	int *m, n, i;
	
	// БЛОК ВВОДА

	puts("Введите кол-во эл-тов масива");
	while(!scanf_s("%d", &n) || n<=0)		//ввод количества элементов массива и проверка правильности ввода
	{
		puts("\nОшибка ввода. Введите число заново");
		fflush(stdin);
	}

	m=(int*)malloc(n*sizeof(int));			//выделение памяти под массив

	if(!m)									//проверка возможности выделения
	{
		puts("Не удалось выделить память.\nНажмите любую клавишу для выхода из программы");
		_getch();
		return 0;
	}

	printf("\nВведите массив\n");			//ввод эт-тов массива
	for (i = 0; i < n; i++)
	{
		printf("m[%d]=", i);
		if ( !scanf_s("%d", m+i) )			//проверка корректности ввода
		{
			printf("Oшибка ввода\n");		
			fflush(stdin);					
			i--;							
		}
	}

	// БЛОК ИЗНАЧАЛЬНОГО ВЫВОДА

	system("CLS");
	puts("Исходный массив:\n");
	for (i = 0; i < n; i++) printf("%5d", *(m+i));

	// БЛОК ВЫПОЛНЕНИЯ ОПЕРАЦИЙ

	//Задание 1: сортировка массива пузырьком
	//bubble(m, n);

	//Задание 2: переместить отриц. эл-ты влево, положительные - влево, не меняя очередность эл-тов.
	sort_all(m, n);

	//Задание 3 схоже с заданием 2, однако введено дополнительное условие: нулевые элементы остаются на своих местах
	//sort_all_by_zero(m, n);

	// БЛОК КОНЕЧНОГО ВЫВОДА

	puts("\n\nПреобразованный массив:\n");
	for (i = 0; i < n; i++) printf("%5d", *(m+i));
	free(m);
	puts("\nПрограмма завершена. Нажмите любую клавиши для выхода из программы");
	_getch();
	return 0;
}



//Задание 1: сортировка массива пузырьком
void bubble(int *m, int n)
{
	int k, i, j;
	for (i = 0; i < n; i++)
	{
		for (j= 0; j < n-1; j++)
			if (*(m+j)>*(m+j+1))
			{
				k=*(m+j);
				*(m+j)=*(m+j+1);
				*(m+j+1)=k;
			}

	}
}

//Задание 2: переместить отриц. эл-ты влево, положительные - вправо, не меняя очередность эл-тов.
void sort_all(int *m, int n)
{
	int ileft=2, var, i, j;									//инициализация дополнительных переменных

	for (i = ileft; i<n-2 && *(m+i)>=0; i++);				//нахождение индекса первого отрицательного элемента
	while (i<n-2)											//поиск и смещение эл-тов будет происходить до тех пор, пока отсортированными не останутся все отр. эл-ты, в этом случае для i вернется значение n
	{
		//происходит перемещения найденного эл-та m[i] на место m[ileft], все эл-ты между ними смещаются
		var=*(m+i);										//m[i] заносится в дополнительную переменную
		for (j=i; j>ileft; j--) *(m+j)=*(m+j-1);		// все остальные элементы смещаются вправо
		*(m+ileft)=var;									// в значение m[ileft] заносится значение var

		ileft++;										//ileft сдвигается для перемещения следующего отр. эл-та
		for (i = ileft; i<n-2 && *(m+i)>=0; i++);			// ищется следующий отрицательный элемент
	}

	// Похожий алгоритм выполняется для нулевых элементов
	for (i = ileft; i<n-2 && *(m+i)!=0; i++);
	while (i<n-2)
	{
		var=*(m+i);
		for (j=i; j>ileft; j--) *(m+j)=*(m+j-1);
		*(m+ileft)=var;
		ileft++;
		for (i = ileft; i<n-2 && *(m+i)!=0; i++);
	}
}

//Задание 3 схоже с заданием 2, однако введено дополнительное условие: нулевые элементы остаются на своих местах
void sort_all_by_zero(int *m, int n)
{
	int ileft=0, var, k, i, j;									//инициализация дополнительных переменных

	for (i = ileft; i<n && *(m+i)>=0; i++);					//нахождение индекса первого отрицательного элемента
	while (*(m+ileft)==0) ileft++;							//

	//поиск и смещение эл-тов будет происходить до тех пор, пока отсортированными не останутся все отр. эл-ты, в этом случае для i вернется значение n
	while (i<n)
	{		
		var=*(m+i);		
		for (j=i; j>ileft;) 
		{
			for (k=j-1; k>ileft && *(m+k)==0; k--);

			*(m+j)=*(m+k);
			j=k;

		}
		*(m+ileft)=var;

		ileft++;	
		while (*(m+ileft)==0) ileft++;						//ileft сдвигается на сле для перемещения следующего отр. эл-та
		for (i = ileft; i<n && *(m+i)>=0; i++);
	}
}
